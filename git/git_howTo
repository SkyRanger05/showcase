Git Version Control --> works a lot better in GitBash

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Feature Branch Workflow
1. Create feature branch
2. Upload to GitHub
3. Create Pull Request
4. Merge feature branch

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Working with staging & commits
Corey Schafer --> when changes (while in the staging & commiting) are not part of other repos but only to one owner repo. History is only at local owner. When the hash of a commit has changed from its previous version, it affects the history. Even when undoing or amending commits. So limit changes to history, especially when the work has already been pushed to remote repo and consequently other owner's repos are copied from the same remote repository, and will otherwise cause problems.

$ls -la
$git checkout <_file_> --> while changes are made but are yet to be staged and before making the commit, will delete the changes made and revert back to the original state of the file.
$git commit --amend -m "_correct message_" --> modify commit message of the last commit after mistake without making another commit
$git commit --amend <press "Enter"> --> modify commited files (by adding more file) of the last commit after forgotten
$git log
$git log --stat --> show file changes within the commit
Cherry pick: moving commits from branch-to-branch (making commits in the wrong branch)
$git log --> copy the hash
$git cherry-pick --> makes commit based-on the previous commit on the other branch by making a copy, recommend to delete the same commit left on the other branch. So switch to the source branch and try not to lose the work or the changes made. In there, do git log to grab the <commit> state desired; and afterwards either $git reset --soft, mixed, --hard like below: 
	$git reset --soft <_hash_> --> not losing the work, this will reset to the commit specified and keeps the changes that were being tracked in the staging area by relocating them back to the staging area before those changes were committed in the cherry-picked, which is now relocated to the other branch.
	$git reset <_hash_> --> note losing the work; defaults to mix reset; similar to reset --soft but keeps the work/changes relocates them to the working-tree.
	$git reset --hard <_hash_> --> lose all the work/changes that were being tracked in association with the cherry-picked commit (pre-update of the index). If untracked files pre-update of index, those are left alone and not deleted.
		Recover work/changes after reset --hard: $git reflog (see below), and then $git checkout <_hash_> (detach state by not being on a branch which will in some point the changes made in detach state will be garbage collected. To save the changes while in detach state, create a branch from it.) then check using $git log to confirm recovery.

$git clean -df --> !!!! WARNING !!!!! 
	Untracked files/directories: it will forever/no recovery get rid of untracked: (d)irectory, & (f)ile
	Recommend: do a dry run

$git reflog --> a walkthough of what was done. 
$git garbage --> collects after 30days those files that were deleted

Corey Schafer --> when changes are part of other repos. Local history are part of other owner's repos. Avoid rewriting local history so that it stays in syn with other owner's repos. Look for alternative to $git reset, see below:

$git revert <_hash_> --> makes new commits to revert/undo the effects of the earlier commit(s) therefore avoiding history revision.



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

$git add <_filename_> --> tracks a particular file
$git add . --> tracks all files in the directory
$git add partword* --> wildcard tracks file with same partwords

Removing files:
$git rm - Remove files from the working tree and from the index
$git rm --cached
$git rm <_filename_> --> does 2 things: a) removes file in the Working Tree, and then b) stages the removal action in the Staging Area; therefore it will also remove the same file in the Staging Area for consistency


Undo a working tree change: effects areas of Git in the Working Tree & Staging Area
The workflow: while in the Working Tree -> analyze the difference between the Working Tree & Staging Area
$git diff
$git checkout --<_filename_> --> Git will discard the changes in the working directory/tree. Discarded changes will be lost since it did not enter into the Staging Area.
$more <_filename_> --> to show proof of the removal affects

Undo staging of files: effects areas of Git in the Staging Area & History
$git reset HEAD <_filename_>

Restore a file from an earlier commit:
$git log --<_filename_> --> to review the affected file & its history
$git chechout <_commit_first5hexidecimalcharacters_> -- <_specificfilename_> --> retrieves the file in the previous version & restores it in the working directory/tree
$ls --> to review the file in the working directory
$git status --> see the retreival file not only restored in the working directory/tree, but also it has been staged automatically & ready to be commited

Git do not track: critical files (secret keys/pass that ARE necessary during development) and/or non critical files (log info, etc.)
.gitignore file --> make a decision about extension names and other ways to be as wide or specific Git will "ignore" from tracking the file
$git status --> to review that the ".gitignore" file is available & if the do not track file is in the working tree is not listed; if true, then commit the ".gitignore" file
$git add & commit .gitignore


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

3 Areas of a Git Repository:
1) Working Tree: is what is visibly in local machine file system; working with files via adding, removing/deleting, editing, etc.
2) Staging Area (Index): receives/takes-in the versions from the Working Tree; then additional changes can be made before making a commit/save-point to be stored in history in .git directory
3) History: equivalent to commit graph stored in .git directory; also stored in this docket are the metadata which in turn are used to create the GitHub repository or can be handed of to anyone and be able to recreate the project with full history

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Top 10 best Git hosting solutions and services in 2021

    Bitbucket.
    GitLab.
    Perforce.
    Beanstalk.
    Amazon AWS CodeCommit.
    Codebase.
    Microsoft Azure DevOps.
    SourceForge.
	Gerrit.


Sep 1, 2021

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

GitHub: Multiple Account --> .gitconfig

# Personal-1 account - default config
Host github.com-<_github_1st-accountname_>
	HostName github.com
	User git
	IdentityFile ~/.ssh/id_rsa<_1st-username_>
# Personal-2 account - colab config
Host github.com-<_github_2nd-accountname_>
        HostName github.com
        User git
        IdentityFile ~/.ssh/id_rsa<_2nd-username_>


[user]
	name = <_useraccountname_>
	email = <_useraccountemail_>

Linking
Linking Github: via cloning vs. manual link
$git clone git@github.com-<_multipleAccounts_>:<_multipleAccounts_>/<_reponame_>.git --> cloning the repo
$git remote add origin git@github.com-<_multipleAccounts_>:<_multipleAccounts_>/<_reponame_>.git --> without cloning
$git merge --[no-]allow-unrelated-histories <_commit_hash_from_remote_> --> use in a manual link

[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[user]
	email = <_useraccountemail_>
	name = <_useraccountname_>
[remote "origin"]
	url = git@github.com-<_username_>:<_useraccount_>/<_reponame_>.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Remote: branching

Remote: can be more than one version control provider (GitHub, GitLab, Bitbucket)

Working with GitHub: remote repositories (totally different from the topic "branch" in which deals with tracking what is happening about a branch  by setting up the connection between local and remote via command: $git branch set-upstream-to )

Scenario 1 --> everything is new: no branch, no files, no history

- in local machine, create a new directory same name as the Github repo a step before and do the following: $git init, create new files and history by commits.
- in Github, create a new repo by naming the repo and that's it, nothing more.
- in local machine, push work to Github:
	=> copy the remote repo's url (not the ssh)
	=> $git remote add origin <_repo-url_> --> configure the reference, "origin" is a conventional way of naming the remote repo. Furthermore, it is possible to add more than one remote references to a single local repo and naming them besides "origin" will be less confusing by its purpose or name of the remote repo provider, e.g. GitLab, Bitbucket ...etc.
	=> $git push -u origin <_name-of-local-branch> --> push the work to the remote repo. The flag "-u" tells the server that a branch which is not yet created on the server side will be pushed and instructs to go ahead create the new branch so that the remote & local are in sync

Scenario 2 --> when local & remote repository have pre-existing histories which are independent of each other.
	=> $git branch -M <_remote-primary-branch-name_> --> change the local primary branch name to match the remote primary branch name.
	=> $git remote add origin <_repo-url_> --> same as Scenario 1
	=> $git push -u origin main --> rejected...due to lack of common history. 
	=> !!! WARNING: REWRITE HISTORY !!! --> Solution 1: $git push -u -f origin main --> the flag "-f" is forcing the files to the server resulting in history revision therefore losing critical files to the project. Bad (or maybe good, depends) for others who have cloned the repo and have the original history when they push their own work, problems and headaches.

	=> !!! ALTERNATIVE: NON-HISTORY REVISION !!! (NOTE: take the initial commit of the remote repo click in the commits & take the "Verified" initial commit id/hash {maybe attach this info when pushing work to the remote repo.})
	Solution 2:
	=> $git pull origin <_name-of-local-branch_> --> brings down updates from the remote.
	=> $git rebase origin/<_remote-branch-name_> --> this pull creates a new branch in the local if not already existed the branch the was pulled. Then it populates local file system with the files pulled from the remote.
	=> $git log --> verify the remote initial commit id/hash
	=> $git merge <_local-branch_> --> merge relevant local branches to reflect the updates.

	Cameron McKenzie Cheat Method: Scenario 2
	=> pre-existing local-repo
	=> pre-exiting remote-repo
	=> $git clone <_remote-repo_> --> a fetch-and-merge method
	=> copy & paste --> local-repo files to the cloned repo. !!! EXCEPTION !!!: DO NOT COPY & PASTE....the.git directory of the local to the remote repo since this is the database for the local.
	=> after copy & paste operation --> delete the local-repo
	=> source-of-truth --> the cloned repo

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Tracking Remotes: branching

Configure the Reference: git config
$git branch --set-upstream-to=origin/<_remote_branchname_> <_local_branch-name_> --> establishes the connection by naming the remote branch & its connection to local branch.

$git push --set-upstream origin <_local-branch other than main_> ---> when created locally a branch therefore there is no upstream branch when pushing from it. This command is used to push the current branch and also set the remote as upstream. To auto setup this given situation, see "push.autoSetupRemote" in "git help config".

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Staging & Committing --> every commit has a 40 hexidecimal SHA1 Hash. First seven characters are shown.
$git status
$git add <_filename_>
$git add <_filename_> ; git commit -m "_message_"
$git commit -m "_message_"
$git commit -a -m "_message_"
$git push
$git push git@github.com - _accountsetupname_:GithubAccount/reponame.git
$git config user.name "_username_"
$git config user.email "_useremail_"
$git config --get remote.origin.url

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

I don't knows
$cat

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
*****
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=<remote>/<branch> feature
*****
fatal: The current branch feature has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin feature

To have this happen automatically for branches without a tracking
upstream, see 'push.autoSetupRemote' in 'git help config'.
*****
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Branching --> used to work in parallel off of the same exact copy. Git automatically creates & names a branch called: main

***

When creating a new branch, set up branch.<name>.remote and branch.<name>.merge configuration entries to set "upstream" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in git status and git branch -v. Furthermore, it directs git pull without arguments to pull from the upstream when the new branch is checked out.

The exact upstream branch is chosen depending on the optional argument: -t, --track, or --track=direct means to use the start-point branch itself as the upstream; --track=inherit means to copy the upstream configuration of the start-point branch.

The branch.autoSetupMerge configuration variable specifies how git switch, git checkout and git branch should behave when neither --track nor --no-track are specified:

***

$ git push --set-upstream origin <_newLocalBranch_> --> to push from new local branch (that, GitHub have no prior knowledge of it) to GitHub main.
$git branch
$git branch --merged
$git branch -a --> shows all the branches: local & remote
$git branch -r --> shows the remote branches only
$git branch <_branchname_> --> creates a new branch locally
$git checkout -b <_branchname_> --> creates new branch and checkout at the same time
$git checkout <_branchname_>
$git branch -d <_branchname_> --> cleanup after merging, when the "HEAD" is pointing to the same commit as with both the "master/main" & the tip of the branch, then the branch can be deleted.
$git branch -D <_branchname_> --> cleanup by force, to force Git to delete a branch that is depended of its "parent-commit"

Local 2nd-Branch --> to push to repo
$git push origin <_local_2nd-branch_> 

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Working Tree: 
Examine & review
$git log --> view the history in the CLI
$git reflog
$git log -p --> to show the changes of each commit
$git log --all --graph
$git log --all --decorate --oneline --graph
$alias graph = "git log --all --decorate --oneline --graph"
$graph
$git diff <_branchname_>..<_otherbranchname_> --> use to analyze the difference between two branches
$git diff --staged --> use to analyze the difference that will be committed between the Staging Area and the History

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Merging

Remotes:
$git branch --set-upstream-to=<_remote_>/<_branch_> <_local_branch_> --> to set tracking information for current local branch
$git pull
$git pull <_remote_> <_branch_> --> to merge with a remote & the tracking information for the current branch.
$git fetch
$git push

Merging Process --> the move IS ALWAYS to the --> "MASTER/MAIN" branch
a) Fast-Forward Merge ("master/main" must be in-sync or ahead of its branches to AFFECT ALL THE CHANGES)--> is when the "master/main branch" has that "direct line/clean commit" to a "parent-commit", which will become the "commit-to-master/main branch" in a merge, with that "parent-commit" having no other copy of it by any other branch. Even with multiple commits in between, the requirement is for the "master/main" to catch up with the branch; and therefore, its copy is "up-to-date" or "in-sync" with the tip of the branch.
$git merge <_branchname_> --> from the "master/main" merge the other branch
$git branch --merged
$git branch -d <_branchname_> --> when the "HEAD" is pointing to the same commit as with both the "master/main" & the tip of the branch, then the branch can be deleted.
$git branch -D <_branchname_> --> to force Git to delete a branch that is depended of its "parent-commit"

b) 3-Way Merge --> when after the "master/main" has caught-up or has "merged-with" one of its branches; will create a "merge commit" so type a commit message. Git examines the "base/parent-commit" of the two branches, along with the tip of those related branches.
$git merge <_otherbranchname-from_off_of_the_same_"parent-commit"_>

Merge Conflicts ("any-changes" will always win!) --> when merging two branches that on each of their tips have changes that took place in the same line of the same file. Git examines the "base-commit" where the divergent have occurred, along with other branches to resolve the changes. The "changes" always wins over "no-changes".
$git merge <_branchname_> --> because there are conflicts, the merging process moves into a <_"master/main-merge"_> area to find resolve.
$git status --> looks different now
$git merge --abort --> to terminate the merging process then returns to normal operations

Resolutions: --> occurs while in the "merging process"
Step 1: fix it how you like it
<<<<<<HEAD
Conflict areas
==========
Conflict areas
>>>>>>OtherBranch

Step 2: stage the resolution like when committing --> git add, then status, then create a "merge commit-message"
Step 3: delete the branch

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Checkout a "commit" --> instead of a branch:
Step 1: choose a commit by using the first 7 hexidigit "commit-hash" --> $git log
Step 2: $git checkout <_first7HexidigitsCommitHash_> --> read the warning, now the "HEAD" is detached

State of HEAD: the HEAD is "detached" when it is pointing to a commit other than the normal "master/main-commit"
Resolution:
A) $git checkout <_branchName_> --> checkout a branch
B) $git branch <_branchName_> --> to proceed normally, create & checkout a new branch from off of this commit that was checked out resulting in a "HEAD" detached state

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

DIRTY !!!
Working Tree/Directory --> is DIRTY! checkedout many branches without merging the changes, checked out commits which will overide the current working tree (so clean it up via committing those changes or stash it before checking out earlier commits), untracked file(s), commits are stacking up, etc....& Git makes it so that it is complicated to do anything.
Stash --> is when the changes are not ready to be staged/committed. In order to have a clean Working Tree/Directory "Temporarily", stash the current tree and then checkout other branches to prevent overriding those changes.

Resolution: save the Working Tree/Directory for later.
Reuse --> stashes can be reused/reapply
$git stash
$git stash save "_message_" --> to better manage the stashes when applying them
$git stash list
$git stash -p
$git stash apply --> by its own, git stash will reapply the most recent stash
$git stash pop --> applies & then removes/delete the most recent stash from the list
$git stash apply <_label_> --> to reuse/reapply the particular stash other than the most recent stash

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Indexing/Staging
$ git rm --cached <filename> --> remove it from the index

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Commit
$ git reset --> in order to recover if you make a commit and then find a mistake immediately after that

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Remotes
$git remote add <user/contributor> <userlocation> --> create the shorthand for remote "git pull"
$git branch -r
$git remote
$git remote -v --> shows remote url
$git fetch --> review and/or save to a branch, then use $git merge origin/master
$git push
$git pull --> combines $git fetch & merge

Remotes via Forks: working with other repos in-collaborative manner 
Setup & workflow: make the fork in GitHub -> then clone to local -> then locally make the changes by following the "Feature Branch Workflow" -> then stay in-sync with all three copies -> then make contributions to the project/original repo via "Pull Request (PR)" in GitHub account -> then post "PR" accepted make a cleanup by deleting both the local and remote branches
Manual process: add upstream remote -> then make a fetch
Auto process: after the fork -> then make a fetch upstream

Stay in-sync:
A "forked-repo": make a fetch & merge/pull upstream 
$git remote add upstream <_forked_repo_address_referrence_> --> for tracking purposes --> immediately then run $git fetch upstream...to start tracking that forked repo
$git fetch upstream --> search for updates in the forked repo
$git merge upstream/master --> to finalize the process of staying in-sync with the forked repo
$git remote remove <_name_of_remote_branch_being_tracked_>
$git remote remove upstream {<_name_of_remote_branch_being_tracked_>} --> removes the upstream branch


$git push ((remote))
 [remote "<name>"]
                url = <URL>
                pushurl = <pushurl>
                push = <refspec>
                fetch = <refspec>

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Configure

$git config --get remote.origin.url
$git config --local user.name "user_name"
$git config --global user.name "user_name"
$git config --local user.email "user_email"
$git config --global user.email "user_email"
$git config --list
$gir config --list --show-origin
$git config --unset <_scope(--local or --global)_> <_property_>
$git config --edit

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
