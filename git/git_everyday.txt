Evereday Git: PART 1 & PART 2
################
!!! WARNING !!!
gggggggggggggggggg
$ git reset --> Be careful with this commands: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don’t use git reset on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use git revert instead.
	--> use "git revert"
$ git clean --> wiped out all files in desktop

################

%%%%% TUTORIAL: PART 1 %%%%%
***** IMPORTING NEW PROJECT *****
$ git help <_subject/topic_>
$ mkdir
$ cd project
$ git init
$ git config
$ git add . ($git rm --cached <file> or $git restore --staged <file> --> to unstage)
$ git commit

***** MAKE CHANGES *****
$ create files in the repo directory
$ git add <file1> <file2> <...> or git update-index --add <file1> <...>
$ make edits and changes

You can see what is about to be committed using git diff with the --cached option:
$ git diff --cached 

"git diff" will show you any changes that you’ve made but not yet added to the index:
$ git diff

$ git restore <file> --> to discard changes in working directory

You can also get a brief summary of the situation with git status:
$ git status

$ finalize the changes desired BEFORE!!! --> the commit to repository
Now, it is ready to make commit.
$ git commit (or: $ git commit -a --> to skip the "add" modified files {but will not add "new files": update-index --add <file>} before the commit)

***** GIT -->> TRACKS "CONTENT", NOT FILES *****
Git’s "add" command does something simpler and more powerful: "git add" is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.

***** VIEWING PROJECT HISTORY *****
At any point you can view the history of your changes using: git log command
$ git log
$ git log -p --> view the complete diffs at each step
$ git log --stat --summary --> often the overview of the change is useful to get a feel of each step

***** MANAGING BRANCHES *****
A single Git repository can maintain multiple branches of development.gi
$ git check-ref-format --branch <branchname> --> checks name formatting
$ git branch <branch_name> --> create new branch
$ git branch --> show list of branches in the Git repo
$ git switch <branch_name> --> to switch to --branch dev-1 a branch

Now in the new branch edit a file, commit the change, and switch back to the master branch:
(edit file)
$ git status
$ git diff
$ git add
Make further changes if needed; BEFORE !!! making the commit to the repository
$ git diff --cached
$ git commit
$ git log --> review the history
$ git switch main

Back in the main branch:
- check that the change you made is no longer visible, since it was made on the experimental branch and you’re back on the master branch.
You can make a different change on the master branch:
(edit the same file as in the other branch)
$ git diff
$ git add
Make further changes if needed; BEFORE !!! making the commit to the repository
$ git diff
$ git add
$ git diff --cached
Now, it is ready to make the commit.
$ git commit

>>> MERGING BRANCHES <<<
At this point the two branches have diverged, with different changes made in each. To merge the changes made in experimental into master, run
$ git merge <branch_name>
If the changes don’t conflict, you’re done. If there are conflicts, markers will be left in the problematic files showing the conflict;
$ git diff --> will show this.

Once you’ve edited the files to resolve the conflicts, continue with the merge of the result of the merge.
$ git add
$ git commit

Finally, "gitk" command will show a nice graphical representation of the resulting history.
$ gitk

At this point you could delete the "branch" this ensures that the changes in the experimental branch are already in the current branch.
$ git branch -d <branch_name> or $ git branch -D <branch_name> --> "-D" option to force delete the branch


***** USING GIT FOR COLLABORATION *****
>>> ON THE SAME MACHINE/HOST <<<
>>> FROM A DIFFERENT MACHINE/HOST <<<


>>> ON THE SAME MACHINE <<<
Feature Branch "Workflow": 
1. Create feature branch
2. Upload to GitHub
3. Create Pull Request
4. Merge feature branch

user$ git clone <location> 
user$ git branch "feature" --> create a feature branch
user$ cd feature branch
user$ edit files
user$ git diff
user$ git add <new modified file>
user$ make further changes
user$ git diff --cached 
user$ Now it is finalize and ready for the commit
user$ git commit
user$ git status
user$ git log [--all, --graph, -p, --stat --summary]
user$ tell the original author to the changes from user repository

Author: "git pull" --> always merges into the "current branch", regardless of what else is given on the command line.
(Note A) that in general, Alice would want her local changes committed -->>> before initiating this "pull". 
		- If Bob’s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge — Alice will have to get rid of her local changes in some way and pull again when this happens).
(Note B) Alice can peek at what Bob did without merging first, using the "fetch" command; 
		- this allows Alice to inspect what Bob did, using a special symbol "FETCH_HEAD", in order to determine if he has anything worth pulling, like this:
		- This operation is safe even if Alice has uncommitted local changes. 
		- The range notation -->>> "HEAD..FETCH_HEAD" means... "show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD".
		- Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.
		- Please note that these range notation can be used with both gitk and "git log".
		- "git stash": Alice may choose to stash her work-in-progress first, do a "pull", and then finally unstash her work-in-progress on top of the resulting history.

(Note A)
author$ commit local changes before git pull and use the tree against the contributor
author$ cd into the project which the user has cloned
author$ git pull <user_location> --> this fetches and then makes a merge: depending on the author's tip-of-HEAD in current branch & possible conflicts

(Note B)
author$ git fetch /home/bob/myrepo master
author$ git log -p HEAD..FETCH_HEAD --> same as "diff <name>..<othername>" in this case a comparison of both the HEAD (author's HEAD vs contributor FETCH_HEAD)
author$ gitk HEAD..FETCH_HEAD --> 2-dots: review what the contributor did since their histories forked
author$ gitk HEAD...FETCH_HEAD --> 3-dots: This means "show everything that is reachable from either one, but exclude anything that is reachable from both of them". Review what both (author & contributor) of them did since they forked.
author$ git stash --> stashes the WIP
author$ git pull <after the "fetch">
author$ unstash

Shorthand: define "remote" repository
Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with git remote, what was fetched is stored in a remote-tracking branch, in this case bob/master. So after this:

author$ git remote add <user/contributor> <userlocation> --> create the shorthand for remote "git pull"

Shows a list of all the changes that Bob made since he branched from Alice’s master branch.
author$ git log -p master..bob/master --> compare changes
author$ git merge bob/master --> After examining those changes, Alice could merge the changes into her master branch..alternatively below 
alice$ git pull . remotes/bob/master --> The merge above can also be done by pulling from her own remote-tracking branch

$ git config --get remote.origin.url --> find out location of remote repository
$ git config -l --> show the complete configuration 

>>> FROM A DIFFERENT MACHINE/HOST <<<
If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:

bob$ git clone alice.org:/home/alice/project myrepo
Alternatively, Git has a native protocol, or can use http; see git-pull(1) for details.

Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see git-push(1) and gitcvs-migration(7).

***** EXPLORING HISTORY *****
Git history is represented as a series of interrelated commits. We have already seen that the git log command can list those commits. Note that first line of each git log entry also gives a name for the commit:
$ git log --> to find out the names of the commits, see first line entry for the SHA-1
$ git show <commit_name> --> either use the long or short name (first 7-characters)
$ git show HEAD
$ git show <branch_name> --> the tip of the branch

Parent(s): 
Every commit usually has one "parent" commit which points to the previous state of the project.
$ git show HEAD^  --> to see the parent of HEAD
$ git show HEAD^^ --> to see the grandparent of HEAD
$ git show HEAD~4 --> to see the great-great grandparent of HEAD

Note that merge commits may have more than one parent:
$ git show HEAD^1 --> show the first parent of HEAD (same as HEAD^)
$ git show HEAD^2 --> show the second parent of HEAD

Custom name commits:
You can also give commits names of your own; after running

$ git tag v2.5 1b2e1d63ff
you can refer to 1b2e1d63ff by the name "v2.5". If you intend to share this name with other people (for example, to identify a release version), you should create a "tag" object, and perhaps sign it; see git-tag(1) for details.

Any Git command that needs to know a commit can take any of these names. 
$ git diff v2.5 HEAD     # compare the current HEAD to v2.5
$ git branch stable v2.5 # start a new branch named "stable" based
                         # at v2.5
$ git reset --hard HEAD^ # reset your current branch and working
                         # directory to its state at HEAD^

$ git grep ["string"] [commit_custom_name] --> can search for strings in any version of your project
$ git grep ["string"] --> git grep will search any of the files it manages in your current directory. So is a quick way to search just the files that are tracked by Git.

Sets of commits:
Many Git commands also take sets of commits, which can be specified in a number of ways
$ git log v2.5..v2.6            # commits between v2.5 and v2.6
$ git log v2.5..                # commits since v2.5
$ git log --since="2 weeks ago" # commits from the last 2 weeks
$ git log v2.5.. Makefile       # commits since v2.5 which modify
                                # Makefile

a "range" of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches "stable" and "master" diverged from a common commit some time ago, then
$ git log stable..master --> will list commits made in the master branch but not in the stable branch
$ git log master..stable --> will show the list of commits made on the stable branch but not the master branch

Weakness: 
The git "log" command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which git log presents those commits is meaningless.

$ gitk --since="2 weeks ago" drivers/ -->> allows you to browse any commits from the last 2 weeks of commits that modified files under the "drivers" directory. (Note: you can adjust gitk’s fonts by holding down the control key while pressing "-" or "+".)

Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:

$ git diff v2.5:Makefile HEAD:Makefile.in
You can also use git show to see any such file:

$ git show v2.5:Makefile




%%%%% TUTOTIAL: PART 2 %%%%%
Important concepts: OBJECT DATABASE & INDEX FILE

Git object types:
- blob
- tree
- commit
- tag

***** GIT OBJECT DATABASE *****
$ create new file "file3"
$ echo 'hello there' > file3
$ git add .
$ git commit -a -m "initial commit"
$ echo 'hello there!" > file3
$ git commit -a -m "add emphasis"
$ git diff-files -p --> review changes to file

What are the 7 digits of hex that Git responded to the commit with?
- It turns out that every object in the Git history is stored under a 40-digit hex name. 
- That name is "the SHA-1 hash of the object’s contents"; among other things, 
- SHA-1 --> ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object’s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.
- All of these GIT-objects are stored under their SHA-1 names inside the Git directory and the contents of these files is just the compressed data plus a header identifying their length and their type. The type is either a blob, a tree, a commit, or a tag.

$ find .git/objects/ --> show git objects

$ git cat-file [options] <_commit object_name/SHA-1_> --> ask git about this particular object

Tree:
- A tree can refer to one or more "blob" objects, each corresponding to a file. 
- In addition, a tree can also refer to other tree objects, thus creating a directory hierarchy. You can examine the contents of any tree using ls-tree (remember that a long enough initial portion of the SHA-1 will also work):
- Initial commit: The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.
- Merge commit: Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.

$ git ls-tree <_commit object_name/SHA-1_>
$ ls .git/objects/??/*
$ git cat-file -t <_commit object_name/SHA01_> | then $ git cat-file <_type_> <_commit object_name/SHA-1_> --> review: tree, parent, etc.
$ cat .git/HEAD | then $ cat. git/<_the result of the former_> --> the simplest commit to find: HEAD commit

Review: tree object or state of the tree
$ git ls-tree <_tree object_name/SHA-1> 

Review: parent object --> it refers to the previous commit
$ git cat-file commit <_commit object_name/SHA-1_>

In summary:
So now we know how Git uses the object database to represent a project’s history:

- "commit" objects refer to "tree" objects representing the snapshot of a directory tree at a particular point in the history, and refer to "parent" commits to show how they’re connected into the project history.

- "tree" objects represent the state of a single directory by associating:
	--> directory names to "blob" objects containing file data; and 
	--> "tree" objects containing subdirectory information.

- "blob" objects contain file data without any other structure.

- References to commit objects at the head of each branch are stored in files under .git/refs/heads/.

- The name of the current branch is stored in .git/HEAD.

Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways—​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.

In command synopses, the word "tree-ish" is sometimes used to designate such an argument.


***** INDEX FILE *****
$ git commit -a --> The primary tool we’ve been using to create commits is git-commit -a, which creates a commit including every change you’ve made to your working tree. 

But what if you want to commit changes only to certain files? Or only certain changes to certain files?
If we look at the way commits are created under the cover, we’ll see that there are more flexible ways creating commits.

continuing with the previous exercise:
$ modify file3
$ echo "hello there, again" >> file3

but this time instead of immediately making the commit, let’s take an intermediate step, and ask for diffs along the way to keep track of what’s happening:
$ git diff --> The last diff is empty, but no new commits have been made, and the head still doesn’t contain the new line:

So git diff is comparing against something other than the head. The thing that it’s comparing against is actually the index file, which is stored in .git/index in a binary format, but whose contents we can examine with ls-files:
$ git ls-files --stage --> examine the binary format of the index file
$ git cat-file -t <_git object_name/SHA-1_> 
$ git cat-file <_type_> <_git objec_name/SHA-1_>
So what our git add did was:
- store a new blob; and 
- then put a reference to it in the index file. 
If we modify the file again, we’ll see that the new modifications are reflected in the git diff output:
$ echo "again?" >> file3
$ git diff

With the right arguments, git diff can also show us the difference between:
- the working directory and the last commit: 
- between the index and the last commit:
At any time, we can create a new commit using git commit (without the "-a" option), and verify that the state committed only includes the changes stored in the index file, not the additional change that is still only in our working tree:
$ git commit -m "repeat" --> repeat the last commit for the purpose of leaving out the "-a" so that the changes in the working tree is not updated to the 'index file'
$ git diff HEAD --> to verify that the changes not staged yet were not included in the commit above.

So by default "git commit" uses the index to create the commit, not the working tree; the "-a" option to commit tells it to first update the index with all changes in the working tree

Finally, it’s worth looking at the effect of git add on the index file:
$ echo "See you later, aligator" > closing
$ git add closing --> to update the "index file" in the .git directory
$ git ls-files --stage --> The effect of the git add was to add one entry to the index file:
$ git cat-file blob <_Git object_name/SHA-1_> --> And, as you can see with cat-file, this new entry refers to the current contents of the file:
$ git status --> The "status" command is a useful way to get a quick summary of the situation

Since the current state of closing.txt is cached in the index file, it is listed as "Changes to be committed". Since file.txt has changes in the working directory that aren’t reflected in the index, it is marked "changed but not updated". At this point, running "git commit" would create a commit that added closing.txt (with its new contents), but that didn’t modify file.txt.

Also, note that a bare git diff shows the changes to file.txt, but not the addition of closing.txt, because the version of closing.txt in the index file is identical to the one in the working directory.

More uses of the "index file" in the .git directory:
- staging area for new commits
- populated from the object database when: checking out a branch, 
- and is used to hold the trees involved in a merge operation. 
See gitcore-tutorial(7) and the relevant man pages for details.
